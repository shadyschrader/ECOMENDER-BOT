
/*
* EcoMender Bot (EB): Task 2B Path Planner
*
* This program computes the valid path from the start point to the end point.
* Make sure you don't change anything outside the "Add your code here" section.
*/

#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <limits.h>
#define V 32

#ifdef __linux__ // for host pc

    #include <stdio.h>

    void _put_byte(char c) { putchar(c); }

    void _put_str(char *str) {
        while (*str) {
            _put_byte(*str++);
        }
    }

    void print_output(uint8_t num) {
        if (num == 0) {
            putchar('0'); // if the number is 0, directly print '0'
            _put_byte('\n');
            return;
        }

        if (num < 0) {
            putchar('-'); // print the negative sign for negative numbers
            num = -num;   // make the number positive for easier processing
        }

        // convert the integer to a string
        char buffer[20]; // assuming a 32-bit integer, the maximum number of digits is 10 (plus sign and null terminator)
        uint8_t index = 0;

        while (num > 0) {
            buffer[index++] = '0' + num % 10; // convert the last digit to its character representation
            num /= 10;                        // move to the next digit
        }
        // print the characters in reverse order (from right to left)
        while (index > 0) { putchar(buffer[--index]); }
        _put_byte('\n');
    }

    void _put_value(uint8_t val) { print_output(val); }

#else  // for the test device

    void _put_value(uint8_t val) { }
    void _put_str(char *str) { }

#endif

// main function
int main(int argc, char const *argv[]) {

    #ifdef __linux__

        const uint8_t START_POINT   = atoi(argv[1]);
        const uint8_t END_POINT     = atoi(argv[2]);
        uint8_t NODE_POINT          = 0;
        uint8_t CPU_DONE            = 0;

    #else
        // Address value of variables for RISC-V Implementation
        #define START_POINT         (* (volatile uint8_t * ) 0x02000000)
        #define END_POINT           (* (volatile uint8_t * ) 0x02000004)
        #define NODE_POINT          (* (volatile uint8_t * ) 0x02000008)
        #define CPU_DONE            (* (volatile uint8_t * ) 0x0200000c)

    #endif

    // array to store the planned path
    uint8_t path_planned[32];
    // index to keep track of the path_planned array
    uint8_t idx = 0;

    /* Functions Usage

    instead of using printf() function for debugging,
    use the below function calls to print a number, string or a newline

    for newline: _put_byte('\n');
    for string:  _put_str("your string here");
    for number:  _put_value(your_number_here);

    Examples:
            _put_value(START_POINT);
            _put_value(END_POINT);
            _put_str("Hello World!");
            _put_byte('\n');
    */

    // ############# Add your code here #############
    uint8_t adj[V * V] = {0};
    struct Vertex {
    	uint8_t status;      // TEMPORARY or PERMANENT
    	uint8_t predecessor; // Predecessor node
    	uint8_t pathLength;  // Path length from start node
    	uint8_t name;        // Store index for node names
};

    struct Vertex vertexList[V];
    uint8_t n = 0; // Number of vertices

    const char *nodeNames[V] = {
    	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
    	"10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
    	"20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
    	"30", "31"
};

    // Initialize the adjacency matrix in 1D


    for(int i = 0; i< V * V; i++)
    {
    	adj[i]=0;
    } 
    adj[0 * V + 1] = 2; // Zero -> One
    adj[0 * V + 10] = 5; // Zero -> Ten
    adj[0 * V + 6] = 8; // Zero -> Six
    
    adj[1 * V + 11] = 2; // One -> Eleven
    adj[1 * V + 2] = 3; // One -> Two
    
    adj[2 * V + 5] = 4; // Two -> Five
    adj[2 * V + 3] = 7; // Two-> three
    adj[2 * V + 4] = 8; // Two -> four
    
    adj[6 * V + 7] = 9; // six -> seven
    adj[6 * V + 8] = 4; // six -> eight
    adj[6 * V + 9] = 6; // six -> nine
    adj[6 * V + 7] = 9; // Six -> Seven
    
    adj[7 * V + 3] = 5; // Seven -> Three
    adj[7 * V + 5] = 3; // Seven -> Five
    adj[7 * V + 8] = 5; // Seven -> Eight
    
    adj[10 * V + 26] = 3; // ten -> twenty-six
    adj[10 * V + 24] = 3; // ten -> twenty-four
    adj[10 * V + 11] = 3; // ten -> eleven
    
    adj[11 * V + 19] = 3; // eleven -> nineteen
    adj[11 * V + 12] = 3; // eleven -> twelve
    	
    adj[12 * V + 13] = 3; // twelve -> thirteen
    adj[12 * V + 14] = 3; // twelve -> fourteen
    
    adj[14 * V + 15] = 3; // fourteen -> fifteen
    adj[14 * V + 16] = 3; // fourteen -> sixteen
    
    adj[16 * V + 17] = 3; // sixteen -> seventeen
    adj[16 * V + 18] = 3; // sixteen -> eighteen
    
    adj[18 * V + 21] = 3; // eighteen -> twenty-one
    adj[18 * V + 19] = 3; // eighteen -> nineteen
    
    adj[19 * V + 20] = 3; // nineteen -> twenty
    
    adj[21 * V + 23] = 3; // twenty-one -> twenty-three
    adj[21 * V + 22] = 3; // twenty-one -> twenty-two
    
    adj[23 * V + 24] = 3; // twenty-three-> twenty-four
    adj[23 * V + 30] = 3; // twenty-three -> thirty
    
    adj[24 * V + 25] = 3; // twenty-four -> twenty-five
    
    adj[26 * V + 28] = 3; // twenty-six -> twenty-eight
    adj[26 * V + 27] = 3; // twenty-six -> twenty-seven
    
    adj[28 * V + 29] = 3; // twenty-eight -> twenty-nine
    adj[28 * V + 30] = 3; // twenty-eight-> thirty

    
    adj[30 * V + 31] = 3; // thirty -> thirty-one
    
    
    
    
    
    
    adj[1 * V + 0] = 2; // Zero -> One
    adj[10 * V + 0] = 5; // Zero -> Ten
    adj[6 * V + 0] = 8; // Zero -> Six
    
    adj[11 * V + 1] = 2; // One -> Eleven
    adj[2 * V + 1] = 3; // One -> Two
    
    adj[5 * V + 2] = 4; // Two -> Five
    adj[3 * V + 2] = 7; // Two-> three
    adj[4 * V + 2] = 8; // Two -> four
    
    adj[7 * V + 6] = 9; // six -> seven
    adj[8 * V + 6] = 4; // six -> eight
    adj[9 * V + 6] = 6; // six -> nine
    adj[6 * V + 7] = 9; // Six -> Seven
    
    adj[3 * V + 7] = 5; // Seven -> Three
    adj[5 * V + 7] = 3; // Seven -> Five
    adj[8 * V + 7] = 5; // Seven -> Eight
    
    adj[26 * V + 10] = 3; // ten -> twenty-six
    adj[24 * V + 10] = 3; // ten -> twenty-four
    adj[11 * V + 10] = 3; // ten -> eleven
    
    adj[19 * V + 11] = 3; // eleven -> nineteen
    adj[12 * V + 11] = 3; // eleven -> twelve
    	
    adj[13 * V + 12] = 3; // twelve -> thirteen
    adj[14 * V + 12] = 3; // twelve -> fourteen
    
    adj[15 * V + 14] = 3; // fourteen -> fifteen
    adj[16 * V + 14] = 3; // fourteen -> sixteen
    
    adj[18 * V + 16] = 3; // sixteen -> seventeen
    adj[17 * V + 16] = 3; // sixteen -> eighteen
    
    adj[21 * V + 18] = 3; // eighteen -> twenty-one
    adj[19 * V + 18] = 3; // eighteen -> nineteen
    
    adj[20 * V + 19] = 3; // nineteen -> twenty
    
    adj[23 * V + 21] = 3; // twenty-one -> twenty-three
    adj[22 * V + 21] = 3; // twenty-one -> twenty-two
    
    adj[24 * V + 23] = 3; // twenty-three-> twenty-four
    adj[30 * V + 23] = 3; // twenty-three -> thirty
    
    adj[25 * V + 24] = 3; // twenty-four -> twenty-five
    
    adj[28 * V + 26] = 3; // twenty-six -> twenty-eight
    adj[27 * V + 26] = 3; // twenty-six -> twenty-seven
    
    adj[29 * V + 28] = 3; // twenty-eight -> twenty-nine
    adj[30 * V + 28] = 3; // twenty-eight-> thirty

    
    adj[31 * V + 30] = 3; // thirty -> thirty-one
    
    
    
    
    
    uint8_t tempVertexMinPL() {
        uint8_t min = 255;
        uint8_t v, x = 255;

        for (v = 0; v < n; v++) {
            if (vertexList[v].status == 1 && vertexList[v].pathLength < min) {
                min = vertexList[v].pathLength;
                x = v;
            }
        }
        return x;
    }   
    
    void dijkstra(uint8_t start) {
        for (uint8_t v = 0; v < n; v++) {
            vertexList[v].status = 1;
            vertexList[v].pathLength = 255;
            vertexList[v].predecessor = 255;
        }

        vertexList[start].pathLength = 0;

        while (true) {
            uint8_t c = tempVertexMinPL();
            if (c == 255) return; 

            vertexList[c].status = 2;

            for (uint8_t v = 0; v < n; v++) {
                uint8_t weight = adj[c * V + v];
                if (weight != 0 && vertexList[v].status == 1) {
                    if (vertexList[c].pathLength + weight < vertexList[v].pathLength) {
                        vertexList[v].predecessor = c;
                        vertexList[v].pathLength = vertexList[c].pathLength + weight;
                    }
                }
            }
        }
    }

    void findPath(uint8_t start, uint8_t end) {
    uint8_t path[V];
    uint8_t count = 0;
    uint8_t sd = 0; // Shortest distance

   
    for (uint8_t v = end; v != start; v = vertexList[v].predecessor) {
        path[count++] = v;
        sd += adj[vertexList[v].predecessor * V + v];
    }
    path[count++] = start; 

    
    for (int i = count - 1; i >= 0; i--) {
        path_planned[idx++] = path[i]; 
    }

    // Output the path and distance
    _put_str("Shortest Path is: ");
    for (int i = count - 1; i >= 0; i--) {
        _put_str((char *)nodeNames[path[i]]); 
        if (i > 0) {
            _put_str((char *)" -> "); 
        }
    }
    
    _put_value(sd); // Print shortest distance
    
}


    // Run Dijkstra's algorithm
    uint8_t start = START_POINT; 
    dijkstra(start);

    // Output the shortest paths from the starting node
    uint8_t end = END_POINT; // Target end point
    if (vertexList[end].pathLength == 255) {
    	_put_str("There is no path from ");
    	_put_value(vertexList[start].name);
    	_put_str(" to ");
    	_put_value(vertexList[end].name);
    	
    	}
    else {	
    	findPath(start, end); // Find and display the path from start to end
}
    // ##############################################

    // the node values are written into data memory sequentially.
    for (int i = 0; i < idx; ++i) {
        NODE_POINT = path_planned[i];
    }
    // Path Planning Computation Done Flag
    CPU_DONE = 1;

    #ifdef __linux__    // for host pc

        _put_str("######### Planned Path #########\n");
        for (int i = 0; i < idx; ++i) {
            _put_value(path_planned[i]);
        }
        _put_str("################################\n");

    #endif

    return 0;
}
